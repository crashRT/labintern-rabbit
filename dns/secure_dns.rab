(* security primitives *)
function pk:1
function enc:2 
function sign:2
function dec:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation dec(enc(x, y), y) = x
equation verify (sign(d, k), d, pk(k)) = true
function hash:1

(*clientとserver*)
type client: process
type dnscache: process
type dnsauth: process

(*channel*)
type udp: channel
type https: channel

channel ch_cache2client: udp
channel ch_client2cache: udp
channel ch_cache2auth: udp
channel ch_auth2cache: udp



syscall send(c, v) {
  put [c::store(v)]
}

syscall recv(c) {
  case 
  | [c::store(v)] →   v 
  end
}

allow client udp [send, recv]
allow dnscache udp [send, recv]
allow dnsauth udp [send, recv]


(*filesystem *)

type dns_records: filesys

syscall fopen (p) {
  (* x はpに束縛されたvalue *)
  case [p.x] ->
    new y = Fd(x) in  (* xを格納したあどれすがy *)
    put [p.x]; y (* caseで[p.x]がなくなってしまうので戻している，そしてyを返す *)
  end
}

syscall fread (y){
  let x = y.Fd in (*p．xのxが取り出せる*)
  x
}

syscall fclose (y) {
  (* これはfree *)
  delete y.Fd 
  }

allow dnsauth dns_records  [fopen, fread, fclose] 

(* attacker *)
attack tamper_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

(* dnscacheやclientが受け取るときに，値が書き換えられてる可能性がある *)
allow attack client [tamper_channel]
allow attack dnscache [tamper_channel]


const fresh auth_pubk
const fresh auth_privk

const fresh cache_pubk
const fresh cache_privk

const fresh tls_symk



process Client(ch_cache_in: udp, ch_cache_out: udp) : client {

    main {
      var domain = "example.com" in
      
      _ :=send(ch_cache_out, domain);

      var cipher = recv(ch_cache_in) in
      (* 復号*)
      var response = dec(cipher, tls_symk) in

      var message = fst(response) in
      var fingerprint = snd(response) in

      case
      | [fingerprint = hash(message)] ->
          var address = snd(message) in
          var response_domain = fst(message) in
          event [::ClientRecvResponse(response_domain, address)]
      end

    }
}

process DNScache(ch_client_in: udp, ch_client_out: udp, ch_auth_out: udp, ch_auth_in: udp) : dnscache {

    main {

        (* クライアントからのクエリを受け取る *)
        var query = recv(ch_client_in) in
        var domain = query in

        (* 権威サーバーに問い合わせ *)
        _ := send(ch_auth_out, domain);

        (* 権威サーバーからの応答を受け取る *)
        var response = recv(ch_auth_in) in
        var address = fst(response) in
        var sig_record = snd(response) in

        (* DNSSECを検証 *)
        var res = verify(sig_record, address, auth_pubk) in

        case
        | [res = true] ->
          (* 検証が成功した場合、キャッシュに保存し、クライアントに返す *)
          event [::Cached(domain, address)];

          var message = (domain, address) in
          var fingerprint = hash(message) in
          var cipher = enc((message, fingerprint), tls_symk) in
          _ := send(ch_client_out, cipher)
        end

    }
}
        
        
process DNSauth (ch_cache_in: udp, ch_cache_out: udp): dnsauth {
  file "/data/record": dns_records = ("example.com", "192.0.2.1")
  var recordpath = "/data/record"

    main {
        (* DNSレコードをファイルから読み込む *)
        var recordfile = fopen(recordpath) in
        var record = fread(recordfile) in

        (* DNSレコードをパース *)
        var domain = fst(record) in
        var address = snd(record) in
        event [::Record(domain, address)];

        (* クエリを待機 *)
        var query = recv(ch_cache_in) in

        (* クエリが一致するか確認 *)
        case 
        | [query = domain] -> 
          (* DNSSECの署名を作成 *)
            var sig = sign(address, auth_privk) in
            _ := send(ch_cache_out, (address, sig))
        end
    }
}



system
    Client(ch_cache2client, ch_client2cache)
    | DNScache(ch_client2cache, ch_cache2client, ch_cache2auth, ch_auth2cache)
    | DNSauth(ch_cache2auth, ch_auth2cache)
requires [
  lemma x:
  corresponds ::Cached(x, y) ~> ::Record(x, y);
  lemma y:
  corresponds ::ClientRecvResponse(x, y) ~> ::Cached(x, y);
  lemma z:
  corresponds ::ClientRecvResponse(x, y) ~> ::Record(x, y)
]